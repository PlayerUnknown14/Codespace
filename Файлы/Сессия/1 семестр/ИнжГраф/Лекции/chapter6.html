<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>Удаление невидимых линий и поверхностей</title>
<link rel="stylesheet" href="main.css" type="text/css">
</head>
<body lang=RU bgcolor="#FFFFFF">
<table width="550" border="0" cellspacing="0" cellpadding="0" align="center">
  <tr>
    <td class="heading1">Удаление невидимых линий и поверхностей</td>
  </tr>
  <tr>
    <td>
      <p>Задачи удаления невидимых линий и поверхностей являются одними из наиболее 
        сложных в машинной графике. Алгоритмы<span style='mso-spacerun:yes'>  
        </span>удаления невидимых линий и поверхностей служат для определения<span style='mso-spacerun:yes'>  
        </span>линий, ребер, поверхностей или объемов, которые видимы или невидимы 
        для наблюдателя, находящегося в заданной точке пространства.</p>
      <p>Необходимость удаления невидимых линий, ребер, поверхностей или объемов 
        проиллюстрированы на (Рис.42).</p>
      <p align="center"><img src="chapter6/figure1.gif" width="523" height="131"></p>
      <p align="center">Рис. 42</p>
      <p>Одному пространственному каркасному изображению куба без удаления невидимых 
        ребер может соответствовать два различных положения куба в пространстве. 
        Или, в общем случае, несколько разных объектов. Алгоритмы<span style='mso-spacerun:yes'>  
        </span>удаления невидимых линий и поверхностей необходимо применять с 
        целью повышения реалистичности изображения для следующих приложений:</p>
      <ul>
        <li> Авиатренажеры 30 кадр/с.</li>
        <li>Машинная мультипликация.</li>
        <li>Виртуальные сцены.</li>
      </ul>
      <p>Все алгоритмы удаления невидимых линий (поверхностей) включает в себя 
        сортировку. Главная сортировка ведется<span style='mso-spacerun:yes'>  
        </span>по геометрическому расстоянию<span style='mso-spacerun:yes'>  </span>от 
        тела, поверхности, ребра или точки до точки наблюдения. Основная идея, 
        положенная в основу сортировки по расстоянию заключается в том, что чем 
        дальше расположен объект от точки наблюдения, тем больше вероятность, 
        что он будет полностью или частично заслонен одним из объектов более близких 
        к точке наблюдения.</p>
      <p>После определения расстояний или приоритетов по глубине остается провести 
        сортировку по горизонтали и вертикали, чтобы выяснить, будет ли рассматриваемый 
        объект действительно заслонен объектом, расположенным ближе к точке наблюдения.</p>
      <p>Эффективность любого алгоритма удаления невидимых линий или поверхностей 
        в большей мере зависит от эффективности процесса сортировки.</p>
      <p>Алгоритмы удаления невидимых линий<span
style='mso-spacerun:yes'>  </span>или поверхностей можно классифицировать по способу 
        выбора системы координат или пространства, в котором они работают. Алгоритмы,<span style='mso-spacerun:yes'>  
        </span>работающие в объектном пространстве, имеют дело с физической системой 
        координат, в которой описаны эти объекты. При этом получаются весьма точные 
        результаты, ограниченные лишь точностью<span style='mso-spacerun:yes'>  
        </span>вычислений. Полученные изображения можно свободно увеличивать несколько 
        раз.</p>
      <p>Алгоритмы, работающие в усеченном мировом пространстве, особенно полезны 
        в тех приложениях, где необходима высокая точность.</p>
      <p>Алгоритмы, работающие в пространстве изображения, имеют дело с системой 
        координат того экрана, на котором объекты <span
style='color:black'>изображаются</span>. При этом точность вычислений ограничена 
        разрешающей способностью экрана. Результаты, полученные в пространстве 
        изображения, а затем увеличенные во много раз не будут соответствовать 
        исходной сцене. Например, могут не совпадать концы отрезков. </p>
      <p>Алгоритмы, формирующие список приоритетов работают попеременно в обеих 
        упомянутых системах координат. Объем вычислений для любого алгоритма, 
        работающего в обычном пространстве и сравнивающего каждый объект сцены 
        со всеми остальными объектами этой сцены, растет теоретически как квадрат 
        числа объектов n<sup>2</sup>.</p>
      <p>Аналогично, объем вычислений любого алгоритма работающего в пространстве 
        изображения и сравнивающего каждый объект сцены с позициями всех пикселов 
        в системе координат<span
style='mso-spacerun:yes'>  </span>экрана растет теоретически как nN.<span style='mso-spacerun:yes'>  
        </span>Здесь<span
style='mso-spacerun:yes'>  </span>n - обозначает количество объектов (тел, плоскостей) 
        в сцене, а N-число пикселов .</p>
      <p>Теоретически трудоемкость алгоритмов работающих в объектном пространстве, 
        меньше трудоемкости алгоритмов работающих в пространстве изображение при 
        n&lt;N. Поскольку N обычно равно 640x480, то теоретически большинство 
        алгоритмов следует реализовать в объектном пространстве. Однако на практике 
        это не так. Дело в том, что алгоритмы, работающие в пространстве изображения, 
        более эффективны, потому что для них легче воспользоваться преимуществом 
        когерентности при растровой реализации.</p>
      <p class="heading2"><a name="float"></a>Алгоритм плавающего горизонта</p>
      <p>Алгоритм плавающего горизонта чаще всего используется для удаления невидимых 
        линий трехмерного представления функций, описывающих поверхность в виде: 
        F(x,y,z) = 0</p>
      <p>Подобные функции возникают во многих приложениях, в<span style='mso-spacerun:yes'>  
        </span>математике, технике, естественных науках и др.</p>
      <p align="center"><img src="chapter6/figure2.gif" width="265" height="234"></p>
      <p align="center">Рис. 43</p>
      <p>Поскольку в приложениях в основном интересуются описанием поверхности, 
        этот алгоритм обычно работает в пространстве изображения.</p>
      <p>Главная идея данного метода заключается в сведении трехмерной задачи 
        к двумерной путем пересечения исходной поверхности последовательностью 
        параллельных секущих плоскостей, имеющих постоянные значения координат<span style='mso-spacerun:yes'>  
        </span>x,y или z (Рис.43).</p>
      <p>Указанные параллельные плоскости, определяются постоянным значением z. 
        Функция F(x,y,z) = 0 сводится к последовательности кривых, лежащих на 
        каждой из этих<span
style='mso-spacerun:yes'>  </span>параллельных плоскостей,<span
style='mso-spacerun:yes'>  </span>например к последовательности<span
style='mso-spacerun:yes'>  </span>y=f(x,z) или x=g(y,z), где<span
style='mso-spacerun:yes'>  </span>z<span
style='mso-spacerun:yes'>  </span>постоянна на каждой из заданных параллельных 
        плоскостей.</p>
      <p>Итак, поверхность теперь складывается из последовательности кривых, лежащих 
        в каждой из этих плоскостей (Рис.44).</p>
      <p align="center"><img src="chapter6/figure3.gif" width="405" height="247"></p>
      <p align="center">Рис. 44</p>
      <p>Здесь предполагается, что полученные кривые являются однозначными функциями 
        независимых переменных.</p>
      <p>Если спроецировать полученные кривые на плоскость z=0 , как показано 
        на рисунке (Рис.45), то сразу становится ясна идея алгоритма удаления 
        невидимых участков исходной поверхности.</p>
      <p align="center"><img src="chapter6/figure4.gif" width="271" height="205"></p>
      <p align="center">Рис. 45</p>
      <p>Алгоритм сначала упорядочивает плоскость z=const<span
style='mso-spacerun:yes'>  </span>по возрастанию расстояния до них от точки наблюдения. 
        Затем для каждой плоскости, начиная с ближайшей к точке наблюдения, строится 
        кривая, лежащая на ней, то есть для каждого значения координаты x в пространстве 
        изображения определяется соответствующее значение y.</p>
      <p>Алгоритм удаления невидимых линий заключается в следующем: </p>
      <p>Если на текущей плоскости при некотором заданном значении x соответствующее 
        значение y на кривой больше значения y для всех предыдущих кривых при 
        этом значении x, то текущая кривая видима в этой точке; в противном случае, 
        она невидима.</p>
      <p>Невидимые участки показаны пунктиром. Реализация данного алгоритма достаточно 
        проста.<span style='mso-spacerun:yes'>  </span>Для хранения максимальных 
        значений y при каждом значении x используется массив, длина которого равна 
        числу различимых точек (разрешению) по оси x<span style='mso-spacerun:yes'>  
        </span>в пространстве изображения.</p>
      <p>Значения, хранящиеся в этом массиве, представляют собой текущие значения 
        &quot;горизонта&quot;. Поэтому, по мере рисования каждой очередной кривой 
        этот горизонт всплывает. Фактически этот алгоритм удаления невидимых линий 
        работает каждый раз с одной линией.</p>
      <p>Алгоритм работает хорошо до тех пор, пока, какая-нибудь очередная кривая 
        не окажется ниже самой первой из кривых, как показано на рисунке (Рис. 
        46).</p>
      <p align="center"><img src="chapter6/figure5.gif" width="337" height="222"></p>
      <p align="center">Рис . 46</p>
      <p>Подобные кривые естественно видимы и представляют собой нижнюю сторону 
        исходной поверхности, однако алгоритм будет считать их невидимыми. Нижняя 
        сторона поверхности делается видимой, если модифицировать этот алгоритм 
        , включив в него нижний горизонт , который опускается вниз по ходу работы 
        алгоритма. Это реализуется при помощи второго массива, длина которого 
        равна числу различимых точек по оси x в пространстве изображения. Этот 
        массив содержит наименьшее значение y для каждого значения x. Алгоритм 
        теперь становится таким:</p>
      <p><i style='mso-bidi-font-style:normal'>Если на текущей плоскости при некотором 
        заданном значении </i><i style='mso-bidi-font-style:
normal'>x соответствующее значение </i><i style='mso-bidi-font-style:normal'>y 
        на кривой больше максимума или меньше минимума по </i><i style='mso-bidi-font-style:normal'>y 
        для всех предыдущих кривых при этом </i><i style='mso-bidi-font-style:normal'>x 
        , то текущая кривая видима.</i></p>
      <p>В противном случае она невидима.</p>
      <p>Полученный результат показан на рисунке (Рис.47).</p>
      <p align="center"><img src="chapter6/figure6.gif" width="313" height="182"></p>
      <p align="center">Рис. 47</p>
      <p>В изложенном алгоритме предполагается, что значение функции, то есть 
        y,<span style='mso-spacerun:yes'>  </span>известно для каждого значения 
        x в пространстве изображения. Однако если для каждого значения x нельзя 
        указать (вычислить) соответствующее ему значение y, то<span
style='font-size:12.0pt;'> </span>невозможно поддерживать массивы верхнего и нижнего 
        плавающих горизонтов в актуальном состоянии.</p>
      <p>В таком случае используется линейная интерполяция значений y между известными 
        значениями для того, чтобы заполнить массивы верхнего и нижнего плавающих 
        горизонтов<span
style='mso-spacerun:yes'>  </span>(Рис. 48).</p>
      <p align="center"><img src="chapter6/figure7.gif" width="404" height="241"></p>
      <p align="center">Рис. 48</p>
      <p>Если видимость кривой меняется, то метод с такой простой интерполяцией 
        не дает корректного<span style='mso-spacerun:yes'>  </span>результата. 
        Это показано на рисунке (Рис.49).</p>
      <p align="center"><img src="chapter6/figure9.gif" width="346" height="173"></p>
      <p align="center">Рис. 49</p>
      <p>Предполагается, что операция по запоминанию массивов проводится после 
        проверки видимости, получаем, что при переходе к текущей кривой от видимого 
        состояния к не видимому состоянию - сегмент AB - точка (x <sub>n</sub><sub>+</sub><sub>k</sub><sub> 
        </sub>, y<sub>n</sub><sub>+</sub><sub>k</sub>) - объявляется невидимой. 
        Тогда участок кривой между точкой (x <sub>n</sub><sub> </sub>, y<sub>n</sub>)<span
style='mso-spacerun:yes'>  </span>и (x <sub>n</sub><sub>+</sub><sub>k</sub>, y<sub>n</sub><sub>+</sub><sub>k</sub>) 
        не изображается и операция по запоминанию массивов не проводится. Образуется 
        зазор между текущей и предыдущей линиями.</p>
      <p>Если на участке текущей кривой происходит переход от невидимого состояния 
        к видимому - сегмент CD - то точка<span
style='mso-spacerun:yes'>  </span>( x <sub>m</sub><sub>+</sub><sub>k</sub><sub> 
        </sub>, y<sub>m</sub><sub>+</sub><sub>k</sub><sub> </sub>) - объявляется 
        видимой, а участок кривой между<span style='mso-spacerun:yes'>  </span>точкой 
        ( x <sub>m</sub>, y<sub>m</sub>) и ( x <sub>m</sub><sub>+</sub><sub>k</sub>, 
        y<sub>m</sub><sub>+</sub><sub>k</sub>) изображается и операция по запоминанию 
        массивов проводится. Поэтому изображается и невидимый кусок сегмента CD. 
      </p>
      <p>Кроме того, массивы плавающих горизонтов не будут содержать точных значений 
        y. А это может повлечь за собой нежелательные дополнительные эффекты для 
        последующих кривых. Следовательно, необходимо решить задачу о поиске точек 
        пересечения текущей и предыдущих кривых.</p>
      <p>Существует несколько методов получения точек пересечения кривых. На растровых 
        дисплеях значения координаты x можно увеличивать на 1,начиная с x <sub>n</sub><sub> 
        </sub>или<sub><span
style='mso-spacerun:yes'>  </span></sub>x<sub>m</sub><sub> </sub>.<span style='mso-spacerun:yes'>  
        </span>Значение<span style='mso-spacerun:yes'>  </span>y , соответствующее 
        текущему значению координаты x в пространстве изображения, получается 
        путем добавления к значению y соответствующему предыдущему значению координаты 
        x , вертикального приращения <sub> <img 
src="chapter6/image003.gif" v:shapes="_x0000_i1029"> </sub> y вдоль заданной 
        кривой. Затем определяется видимость новой точки с координатами (x+1 , 
        y +<sub> <img 
src="chapter6/image003.gif" v:shapes="_x0000_i1030"> </sub> y). Если эта 
        точка видима, то активируется связанный с ней пиксел. Если невидима, то 
        пиксел не активируется, а x увеличивается на 1. Этот процесс продолжается 
        до тех пор, пока не встретится<span
style='mso-spacerun:yes'>  </span>x <sub>n</sub><sub>+</sub><sub>k</sub><sub> 
        </sub>или<span
style='mso-spacerun:yes'>  </span>x <sub>m</sub><sub>+</sub><sub>k</sub> </p>
      <p>Пересечение для растровых дисплеев определяется изложенным методом с 
        достаточной точностью.</p>
      <p>Точное значение точки пересечения двух прямолинейных отрезков, которые 
        интерполируют текущую и предшествующую кривые между точкой<span style='mso-spacerun:yes'>  
        </span>(x <sub>n</sub><sub> </sub>, y<sub>n</sub>) и ( x <sub>n</sub><sub>+</sub><sub>k</sub><sub> 
        </sub>, y<sub>n</sub><sub>+</sub><sub>k</sub>) задается формулами:</p>
      <p><sub> <img
src="chapter6/image005.gif" v:shapes="_x0000_i1031"> </sub> <span style='mso-spacerun:yes'>           
        </span><span
style='font-size:12.0pt;'>, </span>где<span
style='mso-spacerun:yes'>   </span></p>
      <p><sub> <img 
src="chapter6/image003.gif" v:shapes="_x0000_i1026"> </sub> x = x <sub>n</sub><sub>+</sub><sub>k</sub><sub> 
        </sub>- x<sub>n</sub><sub></sub></p>
      <p><sub> <img 
src="chapter6/image003.gif" v:shapes="_x0000_i1027"> </sub> y<sub> p</sub> 
        = (y <sub>n+k</sub>)<sub> p </sub>- (y<sub>n</sub>)<sub> p</sub></p>
      <p><sub> <img 
src="chapter6/image003.gif" v:shapes="_x0000_i1028"> </sub> y<sub> c</sub> 
        = (y <sub>n+k</sub>)<sub> c </sub>- (y<sub>n</sub>)<sub>c</sub></p>
      <p><sub> <img
src="chapter6/image007.gif" v:shapes="_x0000_i1025"> </sub> </p>
      <p><span style='mso-spacerun:yes'> </span>и индексы C - текущая кривая (current)<span
style='mso-spacerun:yes'>  </span>P - предыдущая кривая (previous)</p>
      <p>Результат на (Рис 50).</p>
      <p align="center"><img src="chapter6/figure9.gif" width="346" height="173"></p>
      <p align="center">Рис. 50</p>
      <p>Теперь алгоритм излагается более формально. </p>
      <p>Если на текущей плоскости при некотором заданном значении x соответствующее 
        значение y на кривой больше max или меньше min по y для всех предыдущих 
        кривых, при этом x, то текущая кривая видима. В противном случае она невидима.</p>
      <p>Если на участке от предыдущего x<sub>n</sub><sub> </sub>до текущего x<sub>n</sub><sub>+</sub><sub>k</sub> 
        значения x видимость кривой изменяется, то вычисляется точка пересечения 
        (x<sub>i</sub>).</p>
      <p>Если на участке от x<sub>n</sub> до x<sub>n</sub><sub>+</sub><sub>k</sub> 
        сегмент кривой полностью видим, то он изображается целиком; если он стал 
        невидимым, то изображается фрагмент от x<sub>n</sub> до x<sub>i</sub>; 
        если он был невидим, а стал видим, то изображается фрагмент от (x<sub>i</sub>) 
        до (x<sub>n</sub><sub>+</sub><sub>k</sub> ) .</p>
      <p>Заполнить массивы верхнего и нижнего плавающих горизонтов.<sub> </sub></p>
      <p>Изложенный алгоритм приводит к некоторым дефектам, когда кривая,<span style='mso-spacerun:yes'>  
        </span>лежащая в одной из более удаленных от точки наблюдения плоскостей, 
        появляется слева или справа из под множества кривых, лежащих в плоскостях 
        ближе к наблюдателю. Эффект показан на (Рис. 51).</p>
      <p align="center"><img src="chapter6/figure10.gif" width="319" height="231"></p>
      <p align="center">Рис. 51</p>
      <p>Плоскости n - 1 и n уже обработаны и находятся и находятся ближе к точке 
        наблюдения. Что получается при обработке плоскости n + 1.<span style='mso-spacerun:yes'>  
        </span>После обработки кривых n - 1 и n <u>верхний горизонт</u> для значений 
        x = 0 , x =1 равен начальному значению y. Для значений x от 2 до 17 он 
        равен ординатам кривой n, а для значений 18,19,20 - ординатам кривой n-1. 
        <u>Нижний горизонт</u> для значений x=0 и x=1 равен начальному значению 
        y , для значений x=2,3,4-ординатам кривой n , а для значений x от 5 до20 
        - ординатам кривой n-1.</p>
      <p>При обработке текущей кривой (n+1) алгоритм объявляет ее видимой при 
        x=4. Аналогично эффект возникает справа при x=18. Такой эффект приводит 
        к появлению зазубренных боковых ребер.</p>
      <p>Проблема с зазубренностью боковых ребер решается включением в массивы 
        верхнего и нижнего горизонтов ординат соответствующих штриховым линиям. 
        Это можно эффективно выполнить, создав ложные боковые ребра.</p>
      <p class="heading2"><a name="vertexes"></a>Алгоритм для обоих ребер</p>
      <p class="heading2">Обработка левого бокового ребра <u><span style='font-size:
18.0pt;'></span></u></p>
      <p>Если P<sub>n</sub> является первой точкой на первой кривой, то запомним 
        P<sub>n</sub><sub> </sub>в качестве P<sub>n</sub><sub> -1 </sub>и закончим 
        заполнения. В противном случае создадим ребро, соединяющее P<sub>n</sub><sub> 
        -1 </sub>и P<sub>n</sub><sub> </sub>. Занесем в массивы верхнего и нижнего 
        горизонтов ординаты этого ребра и запомним P<sub>n</sub><sub><span
style='mso-spacerun:yes'>  </span></sub>в качестве P<sub>n</sub><sub> -1 </sub>.</p>
      <p class="heading2">Обработка левого бокового ребра<u></u></p>
      <p>Если P<sub>n</sub><sub><span style='mso-spacerun:yes'>  </span></sub>является 
        последней точкой на правой кривой, то запомним P<sub>n</sub><sub><span
style='mso-spacerun:yes'>  </span></sub>в качестве P<sub>n</sub><sub> -1 </sub>и 
        закончим заполнения. в противном случае создадим ребро, соединяющее P<sub>n</sub><sub><span
style='mso-spacerun:yes'>  </span></sub>и P<sub>n</sub><sub> -1</sub>. Занесем 
        в массивы верхнего и нижнего горизонтов ординаты этого ребра и запомним 
        P<sub>n</sub><sub><span style='mso-spacerun:yes'>  </span></sub>в качестве 
        P<sub>n</sub><sub> -1 </sub>.</p>
      <p>Теперь полный алгоритм выглядит так:</p>
      <p>Для каждой плоскости z=const . </p>
      <p>Обработать левое боковое ребро.</p>
      <p>Для каждой точки лежащей на кривой из текущей плоскости:</p>
      <p>Если при некотором заданном значении x соответствующее значение y на 
        кривой больше max или меньше min но y для всех предыдущих кривых при этом 
        x , то кривая видима в этой точке. В противном случае она невидима.</p>
      <p>Если на сегменте от предыдущего x<sub>n</sub><sub> </sub>до текущего 
        x<sub>n</sub><sub>+</sub><sub>k</sub><sub> </sub>значение x<sub> </sub>, 
        видимость кривой изменяется , то вычисляется пересечение x<sub>i</sub><sub> 
        </sub>.</p>
      <p>Если на участке от x<sub>n</sub><sub> </sub>до x<sub>n</sub><sub>+</sub><sub>k</sub><sub> 
        </sub>сегмент кривой полностью видим, то он изображается целиком; если 
        он стал невидимым, то изображается его кусок от x<sub>n</sub><sub> </sub>до 
        x<sub>i</sub><sub> </sub>; если он стал видимым, то изображается его кусок 
        от x<sub>i</sub><sub> </sub>до x<sub>n</sub><sub>+</sub><sub>k</sub><sub> 
        </sub>.</p>
      <p>Заполнить массив верхнего и нижнего плавающих горизонтов.</p>
      <p><i style='mso-bidi-font-style:normal'>Обработать правое боковое ребро</i></p>
      <p>Если функция содержит очень острые участки (пики), то приведенный алгоритм 
        может дать некоторые результаты. Этот эффект показан на (Рис. 52).</p>
      <p align="center"><img src="chapter6/figure11.gif" width="361" height="231"></p>
      <p align="center">Рис. 52</p>
      <p>Здесь самая нижняя линия (z = 1)<span
style='mso-spacerun:yes'>  </span>содержит пик. При x = 8 следующая линия (z = 
        2) объявляется видимой. При x=12 эта линия (z = 2) объявляется невидимой, 
        определяется точка пересечения, и линия<span
style='mso-spacerun:yes'>  </span>z = 2<span
style='mso-spacerun:yes'>  </span>изображается от x=8 до этой точки. На участке 
        от x=12 до x=16 эта линия (z = 2) вновь становится видимой, определяется 
        новая точка пересечения и кривая изображается от этого пересечения до 
        x=16. Следующая линия (z=3) при x=8 видима, однако она объявляется видимой 
        и при x=12. Следовательно, эта линия изображается на участке от x=8 до 
        x=12 , не смотря на то что она заслонена пиком. Этот эффект вызван вычислением 
        значений функций и оценкой ее видимости на участках, меньше, чем разрешающая 
        способность экрана, то есть тем, что функция задана слишком малым количеством 
        точек. Если встречаются узкие пики,то функцию следует вычислить в точке 
        с абсциссами 0, 2, 4, 6 ... 18, 20 , вместо точек 0, 4, 8, ,12, 16 ... 
        20 то линия z = 3 будет изображена правильно. </p>
      <p class="heading2"><a name="zbuffer"></a>Алгоритм, использующий Z-буфер</p>
      <p>Алгоритм работает в пространстве изображения. Идея z-буфера является 
        простым обобщением идеи о буфере кадра. Буфер кадра используется для запоминания 
        атрибутов (интенсивности) каждого пиксела в пространстве изображения. 
        Z-буфер - это отдельный буфер глубины, используемый для заполнения координаты 
        z или глубины каждого видимого пиксела в пространстве изображения. В процессе 
        работы глубина или значение каждого нового пиксела, который нужно занести 
        в буфер кадра, сравнивается с глубиной того пиксела который занесен уже 
        в z-буфер. Если это сравнение показывает, что новый пиксел расположен 
        впереди пиксела, находящегося в буфере кадра, то новый пиксел заносится 
        в этот буфер и, кроме того, производится корректировка z-буфера новым 
        значением z. Если же сравнение дает противоположный результат, то никаких 
        действий не производится. По сути, алгоритм является поиском по x и y 
        <span
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
mso-char-type:symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:
symbol;mso-symbol-font-family:Symbol'>­</span></span> значения функций z(x , y).</p>
      <p>Главное преимущество алгоритма - его простота. Кроме того, этот алгоритм 
        решает задачу об удаление невидимых поверхностей и делает тривиальной 
        визуализацию пересечений сложных поверхностей. Сцены могут быть любой 
        сложности. Поскольку габариты пространства изображения фиксированы, оценка 
        вычислительной трудоемкости алгоритма не более чем линейна. </p>
      <p>Поскольку элементы сцены или картинки можно заносить в буфер кадра или 
        в z-буфер в произвольном порядке, их ненужно предварительно сортировать 
        по приоритету глубины. Поэтому экономится вычислительное время, затрачиваемое 
        на сортировку по глубине.</p>
      <p>Недостаток алгоритма z-буфера состоит в трудоемкости и высокой стоимости 
        устранения лестничного эффекта, а также реализации эффектов прозрачности 
        и просвечивания. Поскольку алгоритм заносит пикселы в буфер кадра в произвольном 
        порядке, то нелегко получить информацию, необходимую для методов устранения 
        лестничного эффекта.</p>
      <p>При реализации эффектов прозрачности и просвечивания пикселы могут заноситься 
        в буфер кадра в некорректном порядке, что ведет к локальным ошибкам.</p>
      <p class="heading2">Описание Алгоритма Z - буфера</p>
      <p>1. Заполнить буфер кадра фоновым значением интенсивности или цвета.</p>
      <p>2. Заполнить z-буфер минимальным значением z. </p>
      <p>3. Преобразовать каждый многоугольник в растровую форму в произвольном 
        порядке. </p>
      <p>4. Для каждого Пиксел (x, y) в многоугольнике вычислить<span style='mso-spacerun:yes'>  
        </span>его глубину z(x, y).</p>
      <p>5. Сравнить глубину z( x , y ) со значением z <sub>буфер</sub><span style='mso-spacerun:yes'>  
        </span>( x , y ) , хранящимся в z-буфере в этой же<span style='mso-spacerun:yes'>   
        </span>позиции.</p>
      <p>6. Если z( x , y ) &gt;z <sub>буфер</sub> ( x , y ), то записать атрибут 
        этого многоугольника (интенсивность, цвет, и т. п.) в буфер кадра и заменить 
        z <sub>буфер</sub> (x , y)<span
style='mso-spacerun:yes'>  </span>по z(x , y).</p>
      <p>7. В противном случае никаких действий не производится.</p>
      <p>Если известно уравнение плоскости, несущей каждый многоугольник, то вычисление 
        глубины каждого пиксела на сканирующей строке можно проделать пошаговым 
        способом.</p>
      <p>Уравнение плоскости имеет вид: </p>
      <p>ax + by + cz + d = 0 , отсюда</p>
      <p><sub> <img
src="chapter6/image009.gif" v:shapes="_x0000_i1032"> </sub> </p>
      <p>Для сканирующей строки y = const.</p>
      <p>Поэтому глубина пиксела на этой строке, у которой x<sub>1</sub> = x +<sub> 
        <img 
src="chapter6/image003.gif" v:shapes="_x0000_i1035"> </sub> x определяется</p>
      <p><sub> <img
src="chapter6/image011.gif" v:shapes="_x0000_i1033"> </sub> </p>
      <p>или <sub> <img
src="chapter6/image013.gif" v:shapes="_x0000_i1036"> </sub> , но <sub> <img 
src="chapter6/image003.gif" v:shapes="_x0000_i1037"> </sub> x =1. Следовательно</p>
      <p><sub> <img
src="chapter6/image015.gif" v:shapes="_x0000_i1034"> </sub> </p>
      <p>Алгоритм,<span style='mso-spacerun:yes'>  </span>использующий<span style='mso-spacerun:yes'>  
        </span>z буфер<span style='mso-spacerun:yes'>  </span>можно также применять 
        для построения сечений<span style='mso-spacerun:yes'>  </span>поверхностей. 
        Требуется изменить только оператор сравнения.</p>
      <p>z( x , y ) &gt; z <sub>буфер</sub> ( x , y )<span style='mso-spacerun:yes'>  
        </span>and<span
style='mso-spacerun:yes'>  </span>z( x , y ) <span  style='font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;;mso-char-type:
symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:symbol;
mso-symbol-font-family:Symbol'>&pound;</span></span><span
style='mso-spacerun:yes'>  </span>z <sub>сечение</sub> , где z <sub>сечение</sub> 
        - глубина искомого сечения.</p>
      <p>Эффект заключается, в том, что остаются только такие элементы поверхности, 
        которые лежат на самом сечении или позади него. </p>
      <p class="heading2"><a name="realistic"></a>Построение реалистичных изображений</p>
      <p>Построение<span style='mso-spacerun:yes'>  </span>реалистических изображений 
        включает<span style='mso-spacerun:yes'>  </span>как физические и психологические 
        процессы, поскольку<span
style='mso-spacerun:yes'>  </span>свет - электромагнитная<span
style='mso-spacerun:yes'>  </span>энергия, после взаимодействия с<span
style='mso-spacerun:yes'>  </span>окружающей средой попадает в глаз, где и воспринимается 
        мозгом.</p>
      <p class="heading2"><a name="osvechenie"></a>Простая модель освещения</p>
      <p>Световая энергия, падающая на поверхность, может быть поглощена, отражена 
        или пропущена. Частично она поглощается и превращается в тепло, а частично 
        отражается или пропускается. Объект можно увидеть, если он отражает или 
        пропускает свет, если объект поглощает весь падающий свет, то он невидим 
        и называется абсолютно черным телом.</p>
      <p>Количество поглощенной, отраженной или пропущенной энергии света зависит 
        от его длины волны. При освещении белым светом, в котором интенсивность 
        всех длин волн снижена примерно одинаково, объект выглядит серым.</p>
      <p>Если поглощается весь белый свет, то объект кажется черным, а если небольшая 
        его часть, то белым.<span style='mso-spacerun:yes'>  </span>Если поглощаются 
        только определенные длины волн, то у света исходящего от объекта распределяется 
        энергия и объект выглядит цветным. Цвет объекта определяется поглощенными 
        длинами волн. Свойства отраженного света зависят от строения, направления 
        и формы источника света, от ориентации и свойства<span
style='mso-spacerun:yes'>  </span>поверхности. Отраженный от тела свет может также 
        быть диффузным или зеркальным. Диффузное отражение света происходит, когда 
        свет как бы проникает под поверхность объекта, поглощается, а затем вновь 
        испускается. При этом положение наблюдателя не имеет значение, так как 
        диффузно отраженный свет рассеивается равномерно во всех<span style='mso-spacerun:yes'>  
        </span>направлениях. Зеркальное отражение происходит от внешней поверхности 
        объекта. Свет точечного источника отражается от идеального рассеивателя 
        по закону косинусов Ламберта. Интенсивность отраженного света пропорциональна<span style='mso-spacerun:yes'>  
        </span>косинусу<span
style='mso-spacerun:yes'>  </span>угла между направлением света и нормалью к поверхности 
        (Рис. 53).</p>
      <p align="center"><img src="chapter6/figure12.gif" width="180" height="161"></p>
      <p align="center">Рис. 53</p>
      <p>I = I<i
style='mso-bidi-font-style:normal'><sub>l</sub></i> K<sub>d</sub> Cos<span  style='font-family:Symbol;'>q</span><span
style='mso-spacerun:yes'>               </span>0 <span 
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>&pound;</span></span> 
        <span
 style='font-family:Symbol;
'>q </span><span  style='
font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;;mso-char-type:
symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:symbol;
mso-symbol-font-family:Symbol'>&pound;</span></span> <span 
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>p</span></span><span
 style='font-family:Symbol;
'>/2</span></p>
      <p>где I - интенсивность отраженного света;</p>
      <p>I<i style='mso-bidi-font-style:
normal'><sub>l</sub></i><span style='mso-spacerun:yes'>  </span>- интенсивность 
        точного источника; </p>
      <p>K<sub>d</sub> -<span
style='mso-spacerun:yes'>  </span>коэффициент диффузного отражения, K<sub>d</sub><span style='mso-spacerun:yes'>  
        </span>- зависит от материала и длины волны света но в простых моделях 
        обычно считается<span style='mso-spacerun:yes'>  </span>постоянным и принимается<span
style='mso-spacerun:yes'>    </span>0 <span  style='font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;;mso-char-type:
symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:symbol;
mso-symbol-font-family:Symbol'>&pound;</span></span> K<sub>d</sub> <span  style='
font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;;mso-char-type:
symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:symbol;
mso-symbol-font-family:Symbol'>&pound;</span></span> 1;</p>
      <p><span  style='
font-family:Symbol;'>q </span>- угол между направлением света и нормалью к поверхности.</p>
      <p>Поверхность предметов изображенных при помощи простой модели освещения 
        с Ламбертовым<span
style='mso-spacerun:yes'>  </span>диффузным<span style='mso-spacerun:yes'>  </span>отражением 
        выглядит блеклой и матовой. Предполагается, что источник точечный, поэтому 
        объекты, на которые не падает прямой свет, кажутся черными. Обычно на 
        объекты в реальных условиях падает еще и рассеянный свет,<span
style='mso-spacerun:yes'>  </span>отраженный от окружающей объектов и обстановки 
        (стены, потолок и т.д.). Рассеянному свету соответствует распределенный<span
style='mso-spacerun:yes'>  </span>источник.</p>
      <p>Учет источников ведет к вычислительным затратам и это заменяется на константу.</p>
      <p>I = I<sub>a</sub> K<sub>a</sub> +I<i style='mso-bidi-font-style:normal'><sub>l</sub></i> 
        K<sub>d</sub> Cos<span
 style='font-family:Symbol;
'>q</span><span
style='mso-spacerun:yes'>               </span>0 <span 
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>&pound;</span></span> 
        <span  style='font-family:Symbol;'>q </span><span 
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>&pound;</span></span> 
        <span  style='font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:
&quot;Times New Roman&quot;;;mso-char-type:symbol;mso-symbol-font-family:
Symbol'><span style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>p</span></span><span
 style='font-family:Symbol;
'>/2</span>,</p>
      <p>где I<sub>a</sub> -интенсивность рассеянного света;.</p>
      <p>K<sub>a</sub> -коэффициент диффузного отражения рассеянного света (0 
        <span  style='
font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;;mso-char-type:
symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:symbol;
mso-symbol-font-family:Symbol'>&pound;</span></span> K<sub>d</sub> <span 
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>&pound;</span></span> 
        1).<span
style='mso-spacerun:yes'>          </span></p>
      <p>Пусть даны два объекта, одинаково ориентированные<span style='mso-spacerun:yes'>  
        </span>относительно источника, но расположенные на разном расстояние от 
        него. Если найти интенсивность по данной формуле, то она окажется одинаковой. 
        Это значит, что когда<span style='mso-spacerun:yes'>  </span>предметы 
        перекрываются, их невозможно различить, хотя интенсивность света обратно 
        пропорциональна<span
style='mso-spacerun:yes'>  </span>квадрату расстояния от источника, и объект<span
style='mso-spacerun:yes'>  </span>лежащий дальше<span
style='mso-spacerun:yes'>  </span>от него должен быть темнее.<span
style='mso-spacerun:yes'>  </span>Если предположить, что источник света находится 
        в бесконечности, то диффузный член<span style='mso-spacerun:yes'>  </span>модели 
        освещения обратится в нуль.</p>
      <p>В случае перспективного преобразования сцены, в качестве коэффициента 
        пропорциональности для диффузного члена можно взять расстояние d<span
style='mso-spacerun:yes'>  </span>от центра проекции до объекта. Но если центр 
        проекции лежит близко к объекту то<span style='mso-spacerun:yes'>  </span>1/d<sup>2</sup> 
        изменяется очень быстро, т.е.<span style='mso-spacerun:yes'>  </span>у 
        объектов лежащих примерно на одинаковом расстоянии от источника, разница 
        интенсивностей чрезмерно велика. Как показывает опыт,<span style='mso-spacerun:yes'>  
        </span>большей реалистичности можно добиться при линейном затухании. В 
        этом случае модель освещения выглядит так: </p>
      <p><sub> <img
src="chapter6/image017.gif" v:shapes="_x0000_i1041"> </sub> , где К - произвольная<span
style='mso-spacerun:yes'>  </span>постоянная. </p>
      <p>Если точка наблюдения находится в бесконечности, то<span style='mso-spacerun:yes'>  
        </span>d<span
style='mso-spacerun:yes'>  </span>определяется положением объекта, ближайшего 
        к точке наблюдения. Это значит, что ближайший объект освещается полной 
        интенсивностью источника, а более дальние с уменьшенной. </p>
      <p>Для цветных изображений поверхностей модель освещения применяется к каждому 
        из трех основных цветов.</p>
      <p class="heading2"><a name="refraction"></a>Зеркальное отражение</p>
      <p>Интенсивность зеркально отраженного света зависит от угла падения, длины 
        волны падающего света и свойства вещества. Зеркальное отражение света 
        является направленным.</p>
      <p>Угол отражения от идеальной отражающей поверхности равен углу<span style='mso-spacerun:yes'>  
        </span>падения, в любом другом положении наблюдатель не видит зеркально 
        отраженный свет (Рис.54) это значит что вектор S совпадает с вектором 
        R и <span
 style='font-family:Symbol;'>a</span> = 0.</p>
      <p align="center"><img src="chapter6/figure13.gif" width="349" height="259"></p>
      <p align="center">Рис. 54</p>
      <p>Если поверхность не идеальна, то количество света достающего наблюдателя, 
        зависит от пространственного распределения отраженного света. У гладких 
        поверхностей распределение узкое, сфокусированное, у шероховатых поверхностей 
        более широкое. В простых моделях освещения обычно пользуются эмпирической 
        моделью Буи-Туонга Фонга, т .к. физические свойства зеркального отражения 
        очень сложны. Модель Фонга имеет вид. </p>
      <p>I <sub>s</sub>= I<i
style='mso-bidi-font-style:normal'><sub>l</sub></i> W(i , <span  style='
font-family:Symbol;'>l</span>) Cos<sup> </sup><sup>n</sup><span  style='font-family:Symbol;'>a 
        <span
style='mso-spacerun:yes'> </span><span style='mso-spacerun:yes'> </span>, </span>где 
        W(i , <span  style='
font-family:Symbol;'>l</span>) - кривая отражения , представляющая отношение зеркально-отраженного 
        света к падающему , как функцию угла падения i и длины волны <span  style='font-family:Symbol;'>l</span> 
        ; n- степень , аппроксимирующая пространственное распределение зеркально 
        отраженного света.</p>
      <p>Большие значения<span style='mso-spacerun:yes'>  </span>n дают сфокусированные 
        пространственные распределения<span
style='mso-spacerun:yes'>  </span>свойственны для<span
style='mso-spacerun:yes'>  </span>металлов и других блестящих поверхностей, а 
        малые более широкие распределения для неметаллов, например бумаги (Рис.55).</p>
      <p align="center"><img src="chapter6/figure14.gif" width="299" height="182"></p>
      <p align="center">Рис. 55</p>
      <p>Коэффициент зеркального отражения зависит от угла падения, даже при перпендикулярном 
        падении зеркально отражается только часть света, а остальное либо поглощается, 
        либо отражается диффузно. Это соотношение определяется свойствами вещества 
        и<span
style='mso-spacerun:yes'>  </span>длиной волны. Коэффициент отражения для некоторых 
        неметаллов может быть всего 4% в то время как для металлов<span style='mso-spacerun:yes'>  
        </span>80%.</p>
      <p align="center"><img src="chapter6/figure15.gif" width="280" height="211"></p>
      <p align="center">Рис. 56 Коэффициент отражения при нормальном падении света. 
        Длина волны ( х10<sup>-3</sup> ) </p>
      <p align="center"><img src="chapter6/figure16.gif" width="232" height="188"></p>
      <p align="center">Рис. 57. Угол падения . Коэффициент отражения как функция 
        угла падения при <sub><span  style='
font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;;mso-char-type:
symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:symbol;
mso-symbol-font-family:Symbol'>q</span></span></sub>= 90. Коэффициент отражения=100% 
        .<br>
      </p>
      <p>Объединяя эти результаты, с формулой рассеянного света<span style='mso-spacerun:yes'>  
        </span>и диффузного отражения получим модель освещения:</p>
      <p><sub> <img
src="chapter6/image019.gif" v:shapes="_x0000_i1042"> </sub> </p>
      <p>Функция W(i, <span 
style='font-family:Symbol;
'>l</span>) - довольно сложна, поэтому ее заменяют K<sub>s</sub><sub>, </sub><span
style='mso-spacerun:yes'> </span>который выбирается эмпирически.</p>
      <p>Следовательно</p>
      <p><sub> <img
src="chapter6/image021.gif" v:shapes="_x0000_i1043"> </sub> </p>
      <p>В машинной графике эта модель часто называется функцией закраски и применяется 
        для расчета интенсивности или<span
style='mso-spacerun:yes'>  </span>объекта (пикселов). </p>
      <p>Чтобы получить цветное изображение нужно найти функцию закраски для каждого 
        из основных трех цветов.<span
style='mso-spacerun:yes'>  </span>Константа K<sub>s</sub><sub> </sub>обычно одинакова 
        для всех трех цветов.<span style='mso-spacerun:yes'>  </span>Если имеется 
        несколько источников света, то их эффекты суммируются и модель освещения 
        выглядит так:</p>
      <p><sub> <img
src="chapter6/image023.gif" v:shapes="_x0000_i1044"> </sub> </p>
      <p>m - количество источников света. </p>
      <p>Используя формулу скалярного произведения двух векторов, получаем</p>
      <p><sub> <img
src="chapter6/image025.gif" v:shapes="_x0000_i1045"> </sub> , где <span  style='
font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:
&quot;Times New Roman&quot;;;mso-char-type:symbol;mso-symbol-font-family:
Symbol'></span> n иL единичные вектора<span style='mso-spacerun:yes'>  </span>- 
        и направлены к источнику света</p>
      <p><sub> <img
src="chapter6/image027.gif" v:shapes="_x0000_i1046"> </sub> <span
style='mso-spacerun:yes'> </span>, <span  style='font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;;mso-char-type:
symbol;mso-symbol-font-family:Symbol'></span>R<span
style='mso-spacerun:yes'>  </span>и S<span
style='mso-spacerun:yes'>  </span>единичные вектора.</p>
      <p>Следовательно</p>
      <p><sub> <img
src="chapter6/image029.gif" v:shapes="_x0000_i1047"> </sub> </p>
      <p class="heading2"><a name="normal"></a>Определение нормали к поверхности</p>
      <p>Нормаль к поверхности представляет ее локальную кривизну, а следовательно 
        и направление зеркального отражения. Из аналитического описания поверхности 
        нормаль определяется непосредственно. Но для многих поверхностей бывает 
        задана лишь их полигональная аппроксимация Следовательно, зная уравнение 
        каждой грани, можно найти направление нормали.</p>
      <p>Во многих алгоритмах удаления невидимых линий и поверхностей<span style='mso-spacerun:yes'>  
        </span>используются только ребра или вершины, для объединения их с моделью 
        освещения, необходимо знать приближенное значение нормали на ребрах и 
        в вершинах.</p>
      <p>Пусть заданы уравнения плоскостей полигональных граней, тогда нормаль 
        к их общей вершине равна среднему значению нормалей ко всем многоугольникам 
        сходящимся в этой вершине.<span
style='mso-spacerun:yes'>  </span>(Рис.58). </p>
      <p align="center"><img src="chapter6/figure17.gif" width="265" height="195"></p>
      <p align="center">Рис. 58</p>
      <p>Пример: Направление приближенной нормали в точке V1<span style='mso-spacerun:yes'>  
        </span>есть</p>
      <p><span style='mso-spacerun:yes'>  </span>n<sub>v</sub><sub>1</sub>= (a<sub>0</sub> 
        + a<sub>1</sub> +a<sub>4</sub>)i + (b<sub>0</sub>+b<sub>1</sub>+b<sub>4</sub>)j 
        + (c<sub>0</sub>+c<sub>1</sub>+c<sub>4</sub>)k,<span style='mso-spacerun:yes'>  
        </span>где a<sub>0 </sub>, a<sub>1</sub>, a<sub>4</sub>, b<sub>0</sub> 
        .....,. c<sub>0</sub><sub><span
style='mso-spacerun:yes'>   </span></sub><span style='mso-spacerun:yes'> </span>.., 
        коэффициенты уравнения плоскостей<span style='mso-spacerun:yes'>   </span>P<sub>0</sub> 
        ,P<sub>1</sub>, P<sub>4</sub> окружающих точку V1.</p>
      <p>Если требуется найти только направления нормали, то делить результат 
        на количество граней не обязательно.</p>
      <p>Если уравнения плоскостей не заданы, то нормаль к вершине можно определить, 
        усредняя векторные произведения всех ребер, пересекающихся в вершине.</p>
      <p>n<sub> v1</sub>=V<sub>1</sub>V<sub>2</sub>xV<sub>1</sub>V<sub>4</sub>+V<sub>1</sub>V<sub>5</sub>xV<sub>1</sub>V<sub>2</sub>+V<sub>1</sub>V<sub>4</sub>xV<sub>1</sub>V<sub>5</sub></p>
      <p>Пример: Приближенное вычисление нормали к поверхности .</p>
      <p>Рассмотрим усеченную пирамиду .</p>
      <p>Координаты вершины : V1( -1,-1,1)<span style='mso-spacerun:yes'>    </span>V4( 
        -1,1,1 )<span style='mso-spacerun:yes'>    </span>V7 (<span style='mso-spacerun:yes'>  
        </span>2,2,0 )</p>
      <p><span
style='mso-spacerun:yes'>                                            </span>V2(<span style='mso-spacerun:yes'>  
        </span>1,-1,1)<span
style='mso-spacerun:yes'>    </span>V5 ( -2,-2,0)<span
style='mso-spacerun:yes'>    </span>V8 ( -2,2,0)</p>
      <p><span
style='mso-spacerun:yes'>                          </span><span
style='mso-spacerun:yes'>                  </span>V3(<span
style='mso-spacerun:yes'>  </span>1,1,1 )<span style='mso-spacerun:yes'>     </span>V6(<span style='mso-spacerun:yes'>  
        </span>2,-2,0)</p>
      <p>Уравнения плоскостей для граней P<sub>0</sub> ,P<sub>1</sub>, P<sub>4</sub></p>
      <p>P<sub>0</sub> :<span style='mso-spacerun:yes'>    </span>z - 1 = 0</p>
      <p>P<sub>1</sub>:<span style='mso-spacerun:yes'>   </span>-y + z - 2 = 0</p>
      <p>P<sub>4 </sub>:<span style='mso-spacerun:yes'>  </span>-x + z - 2 = 0</p>
      <p>Усреднение нормали к окружающим<span
style='mso-spacerun:yes'>  </span>многоугольникам </p>
      <p>n<sub> 1</sub>=( a<sub> 0</sub> +a<sub> 1</sub> +a<sub> 4 </sub>)i+( 
        a<sub> 0</sub> +a<sub> 1</sub> +a<sub> 4 </sub>)j+( a<sub> 0</sub> +a<sub> 
        1</sub> +a<sub> 4 </sub>)k=-i - j+3k<sub> </sub></p>
      <p>абсолютная величина <span style='
font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:
&quot;Times New Roman&quot;;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>&frac12;</span></span>n<sub> 
        1</sub><span style='font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;mso-char-type:symbol;mso-symbol-font-family:
Symbol'><span style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>&frac12;</span></span>= 
        <sub> <img
src="chapter6/image031.gif" v:shapes="_x0000_i1048"> </sub> <span style='mso-spacerun:yes'> </span>следовательно 
        единичная нормаль</p>
      <p>n<sub> 1 </sub>/<span
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
mso-char-type:symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:
symbol;mso-symbol-font-family:Symbol'>&frac12;</span></span>n<sub> 1</sub><span style='font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:
&quot;Times New Roman&quot;;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>&frac12;</span></span>=-0.3i 
        - 0.3j + 0.9k</p>
      <p>Векторное произведение ребер, сходящихся в вершине V1</p>
      <p>Усредняя векторные произведения получаем приближенную нормаль в точке 
        V1</p>
      <p>n<sub> 1</sub>=-2i-2j+8k<span
style='mso-spacerun:yes'>  </span><span 
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>&THORN;</span></span></p>
      <p><span style='
font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:
&quot;Times New Roman&quot;;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>&frac12;</span></span>n<sub> 
        1</sub><span
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
mso-char-type:symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:
symbol;mso-symbol-font-family:Symbol'>&frac12;</span></span>=<span
style='mso-spacerun:yes'>  </span><sub> <img
src="chapter6/image033.gif" v:shapes="_x0000_i1049"> </sub> <span style='mso-spacerun:yes'>                </span><span
 style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>&THORN;</span></span></p>
      <p>n<sub> 1 </sub>/<span
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
mso-char-type:symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:
symbol;mso-symbol-font-family:Symbol'>&frac12;</span></span>n<sub> 1</sub><span style='font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:
&quot;Times New Roman&quot;;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>&frac12;</span></span>=<span
style='mso-spacerun:yes'>  </span>-0,24i-0,24j+0,94k</p>
      <p>Ненормированные нормали различаются по величине и направлению в зависимости 
        от способа аппроксимации. Следовательно, модель освещения будет иметь 
        различные результаты.</p>
      <p class="heading2"><a name="refrvector"></a>Определение вектора отражения</p>
      <p>Для моделей освещения очень важно правильно задавать направление вектора 
        отражения. По закону отражения, вектор падающего света, нормаль к поверхности 
        и вектор отражения лежат в одной плоскости. И на этой плоскости угол падения 
        равен углу отражения (Рис. 59).</p>
      <p align="center"><img src="chapter6/figure18.gif" width="290" height="214"></p>
      <p align="center">Рис. 59</p>
      <p>Фонг вывел отсюда простое решение для случая, когда свет падает вдоль 
        оси Z. Это предположение удобно для модели освещения с одним точным источником. 
        Если начало системы координат перенести в точку поверхности, то проекция 
        нормали и вектора отражения на плоскости<span style='mso-spacerun:yes'>  
        </span>XY будут лежать на одной прямой (Рис. 60).</p>
      <p align="center"><img src="chapter6/figure19.gif" width="251" height="177"></p>
      <p align="center">Рис. 60</p>
      <p>Таким образом <sub> <img
src="chapter6/image035.gif" v:shapes="_x0000_i1050"> </sub> <span style='mso-spacerun:yes'> </span>, 
        где<span
style='mso-spacerun:yes'>    </span><span style='
font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;mso-char-type:symbol;mso-symbol-font-family:
Symbol'><span style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>`</span></span>R<sub>x</sub><sub> 
        </sub>,<span style='font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:
&quot;Times New Roman&quot;;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>`</span></span>R<sub>y</sub><sub> 
        </sub>,<span
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
mso-char-type:symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:
symbol;mso-symbol-font-family:Symbol'>`</span></span>n<sub>x</sub><sub> </sub>, 
        <span style='font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:
&quot;Times New Roman&quot;;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>`</span></span>n<sub>y</sub><span style='mso-spacerun:yes'>  
        </span>- x и y- составляющие единичных векторов отражения и нормали.</p>
      <p>Обозначим угол между единичным вектором нормали и осью Z через <span style='font-family:
Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
mso-char-type:symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:
symbol;mso-symbol-font-family:Symbol'>q</span></span>.<span style='mso-spacerun:yes'>  
        </span>Тогда составляющая вектора нормали<span
style='mso-spacerun:yes'>  </span>по оси<span style='mso-spacerun:yes'>  </span>Z 
        есть</p>
      <p><span style='
font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:
&quot;Times New Roman&quot;;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>`</span></span>n<sub>z</sub> 
        = Cos<span style='
font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;mso-char-type:symbol;mso-symbol-font-family:
Symbol'><span style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>q</span></span><span
style='mso-spacerun:yes'>             </span>0<span 
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>&pound;</span></span> 
        <span
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
mso-char-type:symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:
symbol;mso-symbol-font-family:Symbol'>q</span></span> <span  style='font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;;mso-char-type:
symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:symbol;
mso-symbol-font-family:Symbol'>&pound;</span></span><span 
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>p</span></span>/2</p>
      <p>Аналогично, угол между единичным вектором отражения<span style='mso-spacerun:yes'>  
        </span>и Z<span
style='mso-spacerun:yes'>  </span>равен<span style='mso-spacerun:yes'>  </span>2<span style='
font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:
&quot;Times New Roman&quot;;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>q</span></span>. Следовательно, 
      </p>
      <p><span
style='mso-spacerun:yes'> </span><span style='
font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;mso-char-type:symbol;mso-symbol-font-family:
Symbol'><span style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>`</span></span>Rz 
        = Cos2<span
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
mso-char-type:symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:
symbol;mso-symbol-font-family:Symbol'>q</span></span> = 2 Cos<sup>2</sup><span style='
font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:
&quot;Times New Roman&quot;;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>q</span></span> - 1=2n<sub>z</sub><sup>2</sup> 
        - 1 </p>
      <p>Известно ,что<span style='mso-spacerun:yes'>  </span>R<sub>x</sub><sup>2</sup>+R<sub> 
        </sub><sub>y</sub><sup>2</sup>+R<sub>z</sub><sup>2</sup> =1 и <span
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
mso-char-type:symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:
symbol;mso-symbol-font-family:Symbol'>`</span></span>R<sub>x</sub><sup>2</sup><sub><span
style='mso-spacerun:yes'>  </span>+</sub><span style='
font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;mso-char-type:symbol;mso-symbol-font-family:
Symbol'><span style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>`</span></span>R<sub>z</sub><sup>2</sup><sub> 
        </sub>= 1- R<sub>z</sub><sup>2</sup> =1- Cos<sup>2</sup>2<span style='font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:
&quot;Times New Roman&quot;;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>q</span></span></p>
      <p><span
style='mso-spacerun:yes'> </span>или <sub> <img
src="chapter6/image037.gif" v:shapes="_x0000_i1051"> </sub> <span
style='mso-spacerun:yes'> </span></p>
      <p>Используя соотношения x и y - составляющих<span style='mso-spacerun:yes'>  
        </span>единичных векторов отражения и нормали и соотношение<span
style='mso-spacerun:yes'>  </span><span style='
font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;mso-char-type:symbol;mso-symbol-font-family:
Symbol'><span style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>`</span></span>n<sub>x</sub><sup>2</sup><sub> 
        </sub>+<span
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
mso-char-type:symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:
symbol;mso-symbol-font-family:Symbol'>`</span></span>n<sub>y</sub><sup>2</sup><sub> 
        </sub>+<span style='font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:
&quot;Times New Roman&quot;;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>`</span></span>n<sub>z</sub><sup>2</sup> 
        = 1</p>
      <p>Получаем<span
style='mso-spacerun:yes'>  </span><sub> <img
src="chapter6/image039.gif" v:shapes="_x0000_i1052"> </sub> </p>
      <p>Перепишем правую часть </p>
      <p><sub> <img
src="chapter6/image041.gif" v:shapes="_x0000_i1053"> </sub> </p>
      <p>или <span style='font-family:
Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
mso-char-type:symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:
symbol;mso-symbol-font-family:Symbol'>`</span></span>R<sub>y</sub><sub> </sub>= 
        2<span
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
mso-char-type:symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:
symbol;mso-symbol-font-family:Symbol'>`</span></span>n<sub>z</sub> n<sub>y</sub><sub></sub></p>
      <p 2>и</p>
      <p>R<sub>x</sub>= 2<span
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
mso-char-type:symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:
symbol;mso-symbol-font-family:Symbol'>`</span></span>n<sub>z</sub> n<sub>x</sub><sub>.</sub></p>
      <p class="heading2"><a name="guro"></a>Закраска методом Гуро</p>
      <p>Если при построении полигональной поверхности для каждой грани используется 
        по одной нормали, то модель освещения создает изображение, состоящее из 
        отдельных многоугольников. Методом Гуро можно получить сглаженное изображение. 
        Для того чтобы изобразить объект методом построчного сканирования, нужно 
        в соответствии с моделью освещения рассчитать интенсивность каждого пиксела. 
        Нормали к поверхности апроксимируются в вершинах многоугольников.</p>
      <p>Однако сканирующая строка не обязательно проходит через вершины многоугольников 
        ().</p>
      <p>При закраске Гуро сначала определяется интенсивность вершин многоугольника, 
        а затем с<span
style='mso-spacerun:yes'>  </span>помощью билинейной интерполяции вычисляется 
        интенсивность<span style='mso-spacerun:yes'>  </span>каждого пиксела на 
        сканирующей строке. Рассмотрим участок полигональной поверхности.</p>
      <p align="center"><img src="chapter6/figure20.gif" width="349" height="203"></p>
      <p align="center">Рис. 61</p>
      <p>Значение интенсивности в точке P определяется линейной интерполяцией 
        в точках Q и R .<span
style='mso-spacerun:yes'>  </span>Для получения интенсивности в точке <span
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
mso-char-type:symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:
symbol;mso-symbol-font-family:Symbol'>q</span></span> - пересечение ребра многоугольника 
        со сканирующей<span style='mso-spacerun:yes'>  </span>строкой нужно с 
        помощью линейной интерполяцией интенсивностей<span style='mso-spacerun:yes'>  
        </span>в точках A и B найти найти интенсивность в точке Q.</p>
      <p>I<sub><span  style='font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;;mso-char-type:
symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:symbol;
mso-symbol-font-family:Symbol'>q</span></span></sub>=uI<sub>A</sub>+(1-u)I<sub>B</sub><span
style='mso-spacerun:yes'>     </span>0<span  style='font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;;mso-char-type:
symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:symbol;
mso-symbol-font-family:Symbol'>&pound;</span></span><span
style='mso-spacerun:yes'>  </span>u <span  style='font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;;mso-char-type:
symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:symbol;
mso-symbol-font-family:Symbol'>&pound;</span></span> 1,</p>
      <p>где <sub> <img
src="chapter6/image043.gif" v:shapes="_x0000_i1054"> </sub> </p>
      <p>Аналогично для R интерполируются интенсивности в вершинах B и C.</p>
      <p>I<sub>R </sub>= wI<sub>B</sub>+(1-w)I<sub>C</sub><span style='mso-spacerun:yes'>     
        </span>0<span  style='font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:
&quot;Times New Roman&quot;;;mso-char-type:symbol;mso-symbol-font-family:
Symbol'><span style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>&pound;</span></span><span style='mso-spacerun:yes'>  
        </span>w <span 
style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>&pound;</span></span> 
        1,</p>
      <p>где <sub> <img
src="chapter6/image045.gif" v:shapes="_x0000_i1038"> </sub> <span style='mso-spacerun:yes'> </span></p>
      <p>Наконец линейной интерполяцией по строке между точками<span style='mso-spacerun:yes'>  
        </span><span style='font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;mso-char-type:symbol;mso-symbol-font-family:
Symbol'><span style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>q</span></span><span
style='mso-spacerun:yes'>  </span>и R находится интенсивность точки P, т.е.</p>
      <p>I<sub>P</sub>=tI<sub><span
 style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>q</span></span></sub>+(1-t)I<sub>R</sub><span
style='mso-spacerun:yes'>     </span>0<span  style='font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;;mso-char-type:
symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:symbol;
mso-symbol-font-family:Symbol'>&pound;</span></span><span
style='mso-spacerun:yes'>  </span>t <span  style='font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;;mso-char-type:
symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:symbol;
mso-symbol-font-family:Symbol'>&pound;</span></span> 1,</p>
      <p>где <sub> <img
src="chapter6/image047.gif" v:shapes="_x0000_i1039"> </sub> </p>
      <p>Значение интенсивности вдоль сканирующей строки можно вычислить инкрементально. 
        Для двух пикселов t<sub>1</sub> и t<sub>2</sub><span
style='mso-spacerun:yes'>  </span>на<span style='mso-spacerun:yes'>  </span>сканирующей 
        строке </p>
      <p>I<sub>P2</sub>=t<sub>2</sub>I<sub><span
 style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>q</span></span></sub>+(1-t<sub>2</sub>)I<sub>R</sub></p>
      <p>I<sub>P1</sub>=t<sub>1</sub>I<sub><span
 style='font-family:Symbol;
mso-ascii-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;;
;mso-char-type:symbol;mso-symbol-font-family:Symbol'><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol'>q</span></span></sub>+(1-t<sub>1</sub>)I<sub>R</sub></p>
      <p>Вычитая, получим, что вдоль строки интенсивность.</p>
      <p>I<sub>P2</sub>= I<sub>P1</sub>+( I<sub><span  style='
font-family:Symbol;mso-ascii-font-family:&quot;Times New Roman&quot;;
mso-hansi-font-family:&quot;Times New Roman&quot;;;mso-char-type:
symbol;mso-symbol-font-family:Symbol'><span style='mso-char-type:symbol;
mso-symbol-font-family:Symbol'>q</span></span></sub><sub> </sub>- I<sub>R</sub>)( 
        t<sub>2</sub>-<sub> </sub>t<sub>1</sub>) = I<sub>P1</sub>+<sub> <img 
src="chapter6/image003.gif" v:shapes="_x0000_i1040"> </sub> I<sub>t</sub>t.</p>
      <p class="heading2"><a name="fong"></a>Закраска Фонга</p>
      <p>Закраска Фонга требует больших<span style='mso-spacerun:yes'>  </span>вычислительных 
        затрат. При закраске Гуро вдоль сканирующей строки интерполируется значение 
        интенсивности, а при Закраске Фонга - вектор нормали, затем он используется 
        в модели освещения для определенной интенсивности. При этом достигается 
        лучшая локальная аппроксимация кривизны поверхности и, следовательно, 
        лучшее изображение.</p>
</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
  </tr>
</table>
</body>
</html>
